---
title: KMP字符串匹配
toc: true
date: 2020-03-09 12:47:30
tags: 算法
categories:
---

KMP学习记录

<!--more-->

## next数组

**next[j] = k 代表**

p[j] 之前的模式串子串中，有长度为k 的相同前缀和后缀，p0 p1, ..., pk-1 = pj-k pj-k+1, ..., pj-1

**已知next [0, ..., j]，求next [j + 1]**

对于P的前j+1个序列字符：

若p[k] == p[j]，则next[j + 1 ] = next [j] + 1 = k + 1；
若p[k ] ≠ p[j]，如果此时p[ next[k] ] == p[j]，则next[ j + 1 ] =  next[k] + 1，否则继续递归前缀索引k = next[k]，而后重复此过程。

**如果p[k] == p[j]，就是再原有最长前后缀的基础上多了一位**

**如果p[k] ≠ p[j]，就找更小的前缀，使得前缀的前缀能和后缀+1位匹配上，由于前缀的后缀是能和后缀匹配上的，所以要找的是前缀的最长公共前后缀**

